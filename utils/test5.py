from particles_import import BoolToSetKV, ObjectP, dynamicparam, Discontinued, PreOP


#Discontinued = str
#PreOP = str
#def BoolToSetKV(*args): return (args)
#ObjectP = BoolToSetKV
#dynamicparam = str
t = {
'Lifespan Decay': 'C_OP_Decay',
'lifespan_decay': 'C_OP_Decay',
    # m_bRopeDecay
'Radius Scale': 'C_OP_InterpolateRadius',
    'radius_start_scale': 'm_flStartScale',
    'radius_end_scale': 'm_flEndScale',
    'start_time': 'm_flStartTime',
    'scale_bias': 'm_flBias',
    'end_time': 'm_flEndTime',
    'ease_in_and_out': 'm_bEaseInAndOut',

'Alpha Fade In Random': 'C_OP_FadeIn',
'alpha_fade_in_random': 'C_OP_FadeIn',
    'proportional 0/1': 'm_bProportional',
    'fade in time min': 'm_flFadeInTimeMin',
    'fade in time max': 'm_flFadeInTimeMax',
    'fade in time exponent': 'm_flFadeInTimeExp',
    'fade in curve exponent': 'm_flFadeInTimeExp', # i guess?

'Alpha Fade Out Random': 'C_OP_FadeOut',
'alpha_fade_out_random': 'C_OP_FadeOut',
    'proportional 0/1': 'm_bProportional',
    'fade out time min': 'm_flFadeOutTimeMin',
    'fade out time max': 'm_flFadeOutTimeMax',
    'ease in and out': 'm_bEaseInAndOut',
    'fade bias': 'm_flFadeBias',
    'fade out time exponent': 'm_flFadeOutTimeExp',

'Movement Basic': 'C_OP_BasicMovement',
    'gravity': 'm_Gravity',
    'drag': 'm_fDrag',
    'max constraint passes': 'm_nMaxConstraintPasses',

'Movement Dampen Relative to Control Point': 'C_OP_DampenToCP',
'Dampen Movement Relative to Control Point': 'C_OP_DampenToCP',
    # m_nControlPointNumber
    'dampen scale': 'm_flScale',
    'falloff range': 'm_flRange',

'Alpha Fade and Decay': 'C_OP_FadeAndKill',
'fade_and_kill': 'C_OP_FadeAndKill',
    'start_fade_in_time': 'm_flStartFadeInTime',
    'end_fade_in_time': 'm_flEndFadeInTime',
    'start_alpha': 'm_flStartAlpha',
    'end_alpha': 'm_flEndAlpha',
    'start_fade_out_time': 'm_flStartFadeOutTime',
    'end_fade_out_time': 'm_flEndFadeOutTime',

'Rotation Basic': 'C_OP_SpinUpdate',
'spin': 'C_OP_SpinUpdate',
    'spin_rate': '', # what? Can't be SpinUpdate then FIXME
'Oscillate Scalar': 'C_OP_OscillateScalar',
'oscillate_scalar': 'C_OP_OscillateScalar',
    'end time max': 'm_flEndTime_max',
    'end time min': 'm_flEndTime_min',
    'oscillation start phase': 'm_flOscAdd',
    'start/end proportional': 'm_bProportionalOp',
    'absolute oscillation': '',
'Oscillate Vector': 'C_OP_OscillateVector',
'oscillate_vector': 'C_OP_OscillateVector',
    'oscillation frequency max': 'm_FrequencyMax',
    'oscillation frequency min': 'm_FrequencyMin',
    'oscillation rate max': 'm_RateMax',
    'oscillation rate min': 'm_RateMin',
    'oscillation field': 'm_nField',
    'oscillation multiplier': 'm_flOscMult',
    'start time max': 'm_flStartTime_max',
    'start time min': 'm_flStartTime_min',
    'end time exponent': Discontinued(),
    'start time exponent': Discontinued(),
    'oscillation frequency exponent': Discontinued(),
    'oscillation rate exponent': Discontinued(),
    # m_bOffset

'Movement Lock to Control Point': 'C_OP_PositionLock',
'postion_lock_to_controlpoint': 'C_OP_PositionLock',
    # m_flJumpThreshold, m_flPrevPosScale
    'lock rotation': 'm_bLockRot',
    'start_fadeout_min': 'm_flStartTime_min',
    'start_fadeout_max': 'm_flStartTime_max',
    'end_fadeout_min': 'm_flEndTime_min',
    'end_fadeout_max': 'm_flEndTime_max',
    'control_point_number': 'm_nControlPointNumber',
    'end_fadeout_exponent': 'm_flEndTime_exp',
    'start_fadeout_exponent': 'm_flStartTime_exp',
    'distance fade range': 'm_flRange',
'Cull when crossing sphere': ('C_OP_DistanceCull', {
    'Cull Distance': 'm_flDistance',
    'Cull inside instead of outside': 'm_bCullInside',
    'Control Point': 'm_nControlPoint',
    # m_flPlaneOffset is from `...crossing plane`
    'Cull plane offset': 'm_flPlaneOffset', # this is a float.. what m_vecPointOffset
}),
'Remap Distance to Control Point to Scalar': ('C_OP_DistanceToCP', {
    'output maximum': 'm_flOutputMax',
    'output minimum': 'm_flOutputMin',
    'output field': 'm_nFieldOutput',
    'distance maximum': 'm_flInputMax',
    'distance minimum': 'm_flInputMin',
    'output is scalar of initial random range': BoolToSetKV('m_nSetMethod', "PARTICLE_SET_SCALE_INITIAL_VALUE"),
    'output is scalar of current value': BoolToSetKV('m_nSetMethod', "PARTICLE_SET_SCALE_CURRENT_VALUE"),
    'only active within specified distance': 'm_bActiveRange',
    'control point': 'm_nStartCP',
}),
'Color Fade': ('C_OP_ColorInterpolate', {
    'color_fade': 'm_ColorFade',
    'fade_start_time': 'm_flFadeStartTime',
    'fade_end_time': 'm_flFadeEndTime',
}),
'Rotation Spin Roll': 'C_OP_Spin',
    'spin_rate_degrees': 'm_nSpinRateDegrees',
    'spin_stop_time': 'm_fSpinRateStopTime',
    'spin_rate_min': 'm_nSpinRateMinDegrees',
'Alpha Fade In Simple': 'C_OP_FadeInSimple',
    'proportional fade in time': 'm_flFadeInTime',
'Cull when crossing plane': 'C_OP_PlaneCull',
    'Control Point for point on plane': 'm_nPlaneControlPoint',
    'Plane Normal': 'm_vecPlaneDirection',
'Set child control points from particle positions': 'C_OP_SetChildControlPoints',
    '# of control points to set': 'm_nNumControlPoints',
    'First control point to set': 'm_nFirstControlPoint',
    'first particle to copy': dynamicparam('m_nFirstSourcePoint'),
    'Group ID to affect': 'm_nChildGroupID',
    'Set cp orientation for particles': 'm_bSetOrientation',
    'Set cp density for particles': Discontinued(),
    'Set cp velocity for particles': Discontinued(),
    'Set cp radius for particles': Discontinued(),
'Alpha Fade Out Simple': 'C_OP_FadeOutSimple',
    'proportional fade out time': 'm_flFadeOutTime',
'Ramp Scalar Linear Random': 'C_OP_RampScalarLinear',
    'ramp rate min': 'm_RateMin',
    'ramp rate max': 'm_RateMax',
    'ramp field': 'm_nField',
'Remap Speed to Scalar': 'C_OP_RemapSpeed',
    'input maximum': 'm_flInputMax',
    'input minimum': 'm_flInputMin',
'Lifespan Minimum Velocity Decay': 'C_OP_VelocityDecay',
    'minimum velocity': 'm_flMinVelocity',
'Rotation Orient Relative to CP': 'C_OP_Orient2DRelToCP',
    'Rotation Offset': 'm_flRotOffset',
    'Spin Strength': 'm_flSpinStrength',
    # rotation field m_nFieldOutput
'Movement Lock to Bone': 'C_OP_LockToBone',
'lock to bone': 'C_OP_LockToBone',
    'lifetime fade start': 'm_flLifeTimeFadeStart',
    'lifetime fade end': 'm_flLifeTimeFadeEnd',
'Cull Random': 'C_OP_Cull',
'Random Cull': 'C_OP_Cull',
    'Cull Percentage': 'm_flCullPerc',
    'Cull End Time': 'm_flCullEnd',
    'Cull Start Time': 'm_flCullStart',
    'Cull Time Exponent': 'm_flCullExp',
'Movement Place On Ground': 'C_OP_MovementPlaceOnGround',
    'include water': 'm_bIncludeWater',
    'max trace length': 'm_flMaxTraceLength',
    'collision group': 'm_CollisionGroupName',
    'offset': 'm_flOffset',
    'kill on no collision': 'm_bKill',
    'interpolation rate': 'm_flLerpRate',
'Remap Scalar': 'C_OP_RemapScalar',
    'input field': 'm_nFieldInput',
'Lifespan Maintain Count Decay': 'C_OP_DecayMaintainCount',
'Remap Control Point to Vector': 'C_OP_RemapCPtoVector',
'Color Light from Control Point': 'C_OP_ControlpointLight',
'Color Light From Control Point': 'C_OP_ControlpointLight',
    'Compute Normals From Control Points': 'm_bUseNormal',
    'Half-Lambert Normals': 'm_bUseHLambert',
    'Clamp Minimum Light Value to Initial Color': 'm_bClampLowerRange',
    'Clamp Maximum Light Value to Initial Color': 'm_bClampUpperRange',
    'Initial Color Bias': 'm_flScale',
    'Light 1 Control Point': 'm_nControlPoint1',
    'Light 2 Control Point': 'm_nControlPoint2',
    'Light 3 Control Point': 'm_nControlPoint3',
    'Light 4 Control Point': 'm_nControlPoint4',
    'Light 1 Control Point Offset': 'm_vecCPOffset1',
    'Light 2 Control Point Offset': 'm_vecCPOffset2',
    'Light 3 Control Point Offset': 'm_vecCPOffset3',
    'Light 4 Control Point Offset': 'm_vecCPOffset4',
    'Light 1 50% Distance': 'm_LightFiftyDist1',
    'Light 1 0% Distance': 'm_LightZeroDist1',
    'Light 2 50% Distance': 'm_LightFiftyDist2',
    'Light 2 0% Distance': 'm_LightZeroDist2',
    'Light 3 50% Distance': 'm_LightFiftyDist3',
    'Light 3 0% Distance': 'm_LightZeroDist3',
    'Light 4 50% Distance': 'm_LightFiftyDist4',
    'Light 4 0% Distance': 'm_LightZeroDist4',
    'Light 1 Color': 'm_LightColor1',
    'Light 2 Color': 'm_LightColor2',
    'Light 3 Color': 'm_LightColor3',
    'Light 4 Color': 'm_LightColor4',
    'Light 1 Type 0=Point 1=Spot': 'm_bLightType1',
    'Light 2 Type 0=Point 1=Spot': 'm_bLightType2',
    'Light 3 Type 0=Point 1=Spot': 'm_bLightType3',
    'Light 4 Type 0=Point 1=Spot': 'm_bLightType4',
    'Light 1 Dynamic Light': 'm_bLightDynamic1',
    'Light 2 Dynamic Light': 'm_bLightDynamic2',
    'Light 3 Dynamic Light': 'm_bLightDynamic3',
    'Light 4 Dynamic Light': 'm_bLightDynamic4',
    'Light 1 Direction': Discontinued(),
    'Light 2 Direction': Discontinued(),
    'Light 3 Direction': Discontinued(),
    'Light 4 Direction': Discontinued(),
    'Light 1 Spot Inner Cone': Discontinued(),
    'Light 1 Spot Outer Cone': Discontinued(),
    'Light 2 Spot Inner Cone': Discontinued(),
    'Light 2 Spot Outer Cone': Discontinued(),
    'Light 3 Spot Inner Cone': Discontinued(),
    'Light 3 Spot Outer Cone': Discontinued(),
    'Light 4 Spot Inner Cone': Discontinued(),
    'Light 4 Spot Outer Cone': Discontinued(),
'Movement Max Velocity': 'C_OP_MaxVelocity',
    'Maximum Velocity': 'm_flMaxVelocity',
'Remap Dot Product to Scalar': 'C_OP_RemapDotProductToScalar',
'remap dot product to scalar': 'C_OP_RemapDotProductToScalar',
    'first input control point': 'm_nInputCP1',
    'second input control point': 'm_nInputCP2',
    'input minimum (-1 to 1)': 'm_flInputMin',
    'input maximum (-1 to 1)': 'm_flInputMin',
    'only active within specified input range': 'm_bActiveRange',
    'use particle velocity for first input': 'm_bUseParticleVelocity',
    # m_bUseParticleNormal
    # m_nSetMethod = PARTICLE_SET_REPLACE_VALUE "PARTICLE_SET_SCALE_INITIAL_VALUE" "PARTICLE_SET_ADD_TO_INITIAL_VALUE" PARTICLE_SET_SCALE_CURRENT_VALUE PARTICLE_SET_ADD_TO_CURRENT_VALUE
'Remap Distance Between Two Control Points to Scalar': 'C_OP_DistanceBetweenCPs',
    'starting control point': 'm_nStartCP',
    'ending control point': 'm_nEndCP',
    'ensure line of sight': 'm_bLOS',
    'LOS collision group': 'm_CollisionGroupName',
    'Maximum Trace Length': 'm_flMaxTraceLength',
    'LOS Failure Scalar': 'm_flLOSScale',
'Remap Control Point to Scalar': 'C_OP_RemapCPtoScalar',
    'input control point number': 'm_nCPInput',
    'input field 0-2 X/Y/Z': 'm_nField',
    'emitter lifetime start time (seconds)': 'm_flStartTime',
    'emitter lifetime end time (seconds)': 'm_flEndTime',
    # m_flInterpRate interp scale
'Movement Match Particle Velocities': 'C_OP_VelocityMatchingForce',
    'Speed Matching Strength': 'm_flSpdScale',
    'Direction Matching Strength': 'm_flDirScale',
    'Control Point to Broadcast Speed and Direction To': 'm_nCPBroadcast',
'Set Control Point Positions': PreOP('C_OP_SetControlPointPositions'),
    'First Control Point Location': 'm_vecCP1Pos',
    'Second Control Point Location': 'm_vecCP2Pos',
    'Third Control Point Location': 'm_vecCP3Pos',
    'Fourth Control Point Location': 'm_vecCP4Pos',
    'First Control Point Number': 'm_nCP1',
    'Second Control Point Number': 'm_nCP2',
    'Third Control Point Number': 'm_nCP3',
    'Fourth Control Point Number': 'm_nCP4',
    'Control Point to offset positions from': 'm_nHeadLocation',
    'First Control Point Parent': Discontinued(),
    'Second Control Point Parent': Discontinued(),
    'Third Control Point Parent': Discontinued(),
    'Fourth Control Point Parent': Discontinued(),
    'Set positions in world space': 'm_bUseWorldLocation',
    # m_bOrient m_bSetOnce
'Set Control Point to Impact Point': PreOP('C_OP_SetControlPointToImpactPoint'),
    'Trace Update Rate': 'm_flUpdateRate',
    'Trace Direction Override': 'm_vecTraceDir',
    'Control Point to Set': 'm_nCPOut',
    'trace collision group': 'm_CollisionGroupName',
    'Control Point to Trace From': 'm_nCPIn',
    'Offset End Point Amount': 'm_flOffset',
    'Max Trace Length': 'm_flTraceLength',
    # m_bSetToEndpoint
"Set Control Point To Particles' Center": PreOP('C_OP_SetControlPointToCenter'),
    'Control Point Number to Set': 'm_nCP1',
    'Center Offset': 'm_vecCP1Pos', # duplicate????? why have you done this
    'center offset': 'm_vecCP1Pos',
    'basic_movement': Discontinued(),
'radius_scale': 'C_OP_InterpolateRadius',
'alpha_fade': 'C_OP_FadeAndKill', # C_OP_FadeOutSimple
'rotation_spin': 'C_OP_Spin', # rotation spin roll ?????
'Rotation Spin Yaw': 'C_OP_SpinYaw',
'rotation_spin yaw': 'C_OP_SpinYaw',
    'yaw_rate_degrees': 'm_nSpinRateDegrees',
    'yaw_rate_min': 'm_nSpinRateMinDegrees',
    'yaw_stop_time': 'm_fSpinRateStopTime',
'Remap CP Speed to CP': PreOP('C_OP_RemapSpeedtoCP'),
    'input control point': 'm_nInControlPointNumber',
    'output control point': 'm_nOutControlPointNumber',
    'Output field 0-2 X/Y/Z': 'm_nField', # didnt check
'Remap Difference of Sequential Particle Vector to Scalar': 'C_OP_DifferencePreviousParticle',
    'difference minimum': 'm_flInputMin',
    'difference maximum': 'm_flInputMax',
    'also set ouput to previous particle': 'm_bSetPreviousParticle',
'Movement Maintain Position Along Path': 'C_OP_MaintainSequentialPath',
    'particles to map from start to end': 'm_flNumToAssign',
    'cohesion strength': 'm_flCohesionStrength',
    'maximum distance': 'm_fMaxDistance',
    'restart behavior (0 = bounce, 1 = loop )': 'm_bLoop',
    'use existing particle count': 'm_bUseParticleCount',
    'control point movement tolerance': 'm_flTolerance',
    **(_m_PathParams:={'bulge': ObjectP('m_PathParams', 'm_flBulge'), # random bulge? m_flBulge
    'start control point number': ObjectP('m_PathParams', 'm_nStartControlPointNumber'),
    'end control point number': ObjectP('m_PathParams', 'm_nEndControlPointNumber'),
    'bulge control 0=random 1=orientation of start pnt 2=orientation of end point':\
        ObjectP('m_PathParams', 'm_nBulgeControl'),
    'mid point position': ObjectP('m_PathParams', 'm_flMidPoint'),}),
'Ramp Scalar Spline Random': 'C_OP_RampScalarSpline',
    'ease out': 'm_bEaseOut',
'Remap Velocity to Vector': 'C_OP_RemapVelocityToVector',
    'normalize': 'm_bNormalize',
'Ramp Scalar Spline Simple': 'C_OP_RampScalarSplineSimple',
    'ramp rate': 'm_Rate',
'Ramp Scalar Linear Simple': 'C_OP_RampScalarLinearSimple',
    'end time': '',
'Noise Vector': ('C_OP_VectorNoise', {
    'noise coordinate scale': 'm_fl4NoiseScale',
    # m_bAdditive m_bOffset m_flNoiseAnimationTimeScale
}),
'Set Control Point To Player': PreOP('C_OP_SetControlPointToPlayer'),
    'Control Point Number': 'm_nCP1',
    'Control Point Offset': 'm_vecCP1Pos',
    # m_bOrientToEyes
'Oscillate Scalar Simple': 'C_OP_OscillateScalarSimple',
    'oscillation rate': 'm_Rate',
    'oscillation frequency': 'm_Frequency',
'Normal Lock to Control Point': 'C_OP_NormalLock',#'C_OP_CalculateVectorAttribute',
'Inherit Attribute From Parent Particle': 'C_OP_InheritFromParentParticlesV2',
    'Inherited Field': 'm_nFieldOutput',
'Movement Lock to Saved Position Along Path': 'C_OP_LockToSavedSequentialPathV2',
    'Use sequential CP pairs between start and end point': 'm_bCPPairs',
    **_m_PathParams,
'Restart Effect after Duration': 'C_OP_RestartAfterDuration',
    'Minimum Restart Time': '',
    'Maximum Restart Time': '',
'Set per child control point from particle positions': 'C_OP_SetPerChildControlPoint',
    'control point to set': '',
    '# of children to set': 'm_nNumControlPoints', # made up
'Remap Percentage Between Two Control Points to Scalar': 'C_OP_PercentageBetweenCPs',
    'treat distance between points as radius': '',
    'percentage maximum': '',
    'percentage minimum': '',
'Remap Direction to CP to Vector': 'C_OP_RemapDirectionToCPToVector',
    'scale factor': '',
    'offset rotation': '',
    'offset axis': '',
'Lerp Initial Scalar': 'C_OP_LerpScalar',
    'value to lerp to': '',
    'start time': '',
'Lifespan Minimum Alpha Decay': 'C_OP_AlphaDecay',
    'minimum alpha': '',
'Clamp Scalar': 'C_OP_ClampScalar',
'Set Control Point Rotation': (PreOP('C_OP_SetControlPointRotation'), {
    'Rotation Rate': dynamicparam('m_flRotRate'),
    'Rotation Axis': dynamicparam('m_vecRotAxis'),
    'Control Point': 'm_nCP',
    'Local Space Control Point': 'm_nLocalCP',
}), 
'Lifespan Minimum Radius Decay': 'C_OP_RadiusDecay',
'Set control points from particle positions': 'C_OP_SetControlPointsToParticle',
'Alpha Fade and Decay for Tracers': 'C_OP_FadeAndKillForTracers',
'Noise Scalar': 'C_OP_Noise',
'Rotation Orient to 2D Direction': 'C_OP_OrientTo2dDirection',
'Rotate Vector Random': 'C_OP_RotateVector',
    'Rotation Rate Min': '',
    'Rotation Rate Max': '',
'Movement Rotate Particle Around Axis': 'C_OP_MovementRotateParticleAroundAxis',
    'Use Local Space': 'm_bLocalSpace',
'Clamp Vector': ('C_OP_ClampVector',{

}),
'Oscillate Vector Simple': 'C_OP_OscillateVectorSimple',
'Lerp EndCap Scalar': 'C_OP_LerpEndCapScalar',
'Lerp EndCap Vector': 'C_OP_LerpEndCapVector',
'Lerp Initial Vector': 'C_OP_LerpVector',
'Remap Model Volume to CP': 'C_OP_RemapModelVolumetoCP',
'Remap Particle BBox Volume to CP': 'C_OP_RemapBoundingVolumetoCP',
'Remap Average Scalar Value to CP': 'C_OP_RemapAverageScalarValuetoCP',
'Remap Distance Between Two Control Points to CP': ('C_OP_DistanceBetweenCPsToCP',{
    'output control point': 'm_nOutputCP',
}),
'Remap Percentage Between Two Control Points to Vector': ('C_OP_PercentageBetweenCPsVector',{

}),
'Movement Lerp to Hitbox': 'C_OP_MoveToHitbox',
'Set CP Offset to CP Percentage Between Two Control Points': 'C_OP_CPOffsetToPercentageBetweenCPs',
'Cull relative to model': 'C_OP_ModelCull',
'Movement Maintain Offset': 'C_OP_MovementMaintainOffset',
'Stop Effect after Duration': 'C_OP_StopAfterCPDuration',
'Movement Lag Compensation': 'C_OP_LagCompensation',
'Remap CP Velocity to Vector': 'C_OP_RemapCPVelocityToVector',
'Set CP Orientation to CP Direction': 'C_OP_SetCPOrientationToDirection',
'Normalize Vector': 'C_OP_NormalizeVector',
'Remap Control Point Direction to Vector': 'C_OP_RemapControlPointDirectionToVector',
'Remap Distance to Control Point to Vector': NotImplemented, # maybe C_OP_RemapDistanceToLineSegmentToVector
'Distance to Control Points Scale': NotImplemented,
}

t2 = {
'Movement Basic': ('C_OP_BasicMovement', {
    'gravity': 'm_Gravity',
    'drag': 'm_fDrag',
    'max constraint passes': 'm_nMaxConstraintPasses',
}),
'Alpha Fade and Decay': ('C_OP_FadeAndKill', {        
    'start_alpha': 'm_flStartAlpha',
    'end_alpha': 'm_flEndAlpha',
    'start_fade_in_time': 'm_flStartFadeInTime',      
    'end_fade_in_time': 'm_flEndFadeInTime',
    'start_fade_out_time': 'm_flStartFadeOutTime',
    'end_fade_out_time': 'm_flEndFadeOutTime',
}),
'Alpha Fade and Decay for Tracers': ('C_OP_FadeAndKillForTracers', {
    'start_alpha': 'm_flStartAlpha',
    'end_alpha': 'm_flEndAlpha',
    'start_fade_in_time': 'm_flStartFadeInTime',
    'end_fade_in_time': 'm_flEndFadeInTime',
    'start_fade_out_time': 'm_flStartFadeOutTime',
    'end_fade_out_time': 'm_flEndFadeOutTime',
}),
'Alpha Fade In Random': ('C_OP_FadeIn', {
    'fade in time min': 'm_flFadeInTimeMin',
    'fade in time max': 'm_flFadeInTimeMax',
    'fade in time exponent': 'm_flFadeInTimeExp',
    'proportional 0/1': 'm_bProportional',
}),
'Alpha Fade Out Random': ('C_OP_FadeOut', {
    'fade out time min': 'm_flFadeOutTimeMin',
    'fade out time max': 'm_flFadeOutTimeMax',
    'fade out time exponent': 'm_flFadeOutTimeExp',
    'proportional 0/1': 'm_bProportional',
    'ease in and out': 'm_bEaseInAndOut',
    'fade bias': 'm_flFadeBias',
}),
'Alpha Fade In Simple': ('C_OP_FadeInSimple', {
    'proportional fade in time': 'm_flFadeInTime',
}),
'Alpha Fade Out Simple': ('C_OP_FadeOutSimple', {
    'proportional fade out time': 'm_flFadeOutTime',
}),
'Clamp Scalar': ('C_OP_ClampScalar', {
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
}),
'Clamp Vector': ('C_OP_ClampVector', {
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_vecOutputMin',
    'output maximum': 'm_vecOutputMax',
}),
'Oscillate Scalar': ('C_OP_OscillateScalar', {
    'oscillation field': 'm_nField',
    'oscillation rate min': 'm_RateMin',
    'oscillation rate max': 'm_RateMax',
    'oscillation frequency min': 'm_FrequencyMin',
    'oscillation frequency max': 'm_FrequencyMax',
    'proportional 0/1': 'm_bProportional',
    'start time min': 'm_flStartTime_min',
    'start time max': 'm_flStartTime_max',
    'end time min': 'm_flEndTime_min',
    'end time max': 'm_flEndTime_max',
    'start/end proportional': 'm_bProportionalOp',
    'oscillation multiplier': 'm_flOscMult',
    'oscillation start phase': 'm_flOscAdd',
}),
'Oscillate Scalar Simple': ('C_OP_OscillateScalarSimple', {
    'oscillation field': 'm_nField',
    'oscillation rate': 'm_Rate',
    'oscillation frequency': 'm_Frequency',
    'oscillation multiplier': 'm_flOscMult',
    'oscillation start phase': 'm_flOscAdd',
}),
'Oscillate Vector': ('C_OP_OscillateVector', {
    'oscillation field': 'm_nField',
    'oscillation rate min': 'm_RateMin',
    'oscillation rate max': 'm_RateMax',
    'oscillation frequency min': 'm_FrequencyMin',
    'oscillation frequency max': 'm_FrequencyMax',
    'proportional 0/1': 'm_bProportional',
    'start time min': 'm_flStartTime_min',
    'start time max': 'm_flStartTime_max',
    'end time min': 'm_flEndTime_min',
    'end time max': 'm_flEndTime_max',
    'start/end proportional': 'm_bProportionalOp',
    'oscillation multiplier': 'm_flOscMult',
    'oscillation start phase': 'm_flOscAdd',
}),
'Oscillate Vector Simple': ('C_OP_OscillateVectorSimple', {
    'oscillation field': 'm_nField',
    'oscillation rate': 'm_Rate',
    'oscillation frequency': 'm_Frequency',
    'oscillation multiplier': 'm_flOscMult',
    'oscillation start phase': 'm_flOscAdd',
}),
'Remap Difference of Sequential Particle Vector to Scalar': ('C_OP_DifferencePreviousParticle', {
    'difference minimum': 'm_flInputMin',
    'difference maximum': 'm_flInputMax',
    'input field': 'm_nFieldInput',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'output is scalar of initial random range': 'm_bScaleInitialRange',
    'only active within specified difference': 'm_bActiveRange',
    'also set ouput to previous particle': 'm_bSetPreviousParticle',
}),
'Remap Scalar': ('C_OP_RemapScalar', {
    'input field': 'm_nFieldInput',
    'input minimum': 'm_flInputMin',
    'input maximum': 'm_flInputMax',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
}),
'Lerp Initial Scalar': ('C_OP_LerpScalar', {
    'start time': 'm_flStartTime',
    'end time': 'm_flEndTime',
    'output field': 'm_nFieldOutput',
    'value to lerp to': 'm_flOutput',
}),
'Lerp EndCap Scalar': ('C_OP_LerpEndCapScalar', {
    'lerp time': 'm_flLerpTime',
    'output field': 'm_nFieldOutput',
    'value to lerp to': 'm_flOutput',
}),
'Lerp EndCap Vector': ('C_OP_LerpEndCapVector', {
    'lerp time': 'm_flLerpTime',
    'output field': 'm_nFieldOutput',
    'value to lerp to': 'm_vecOutput',
}),
'Lerp Initial Vector': ('C_OP_LerpVector', {
    'start time': 'm_flStartTime',
    'end time': 'm_flEndTime',
    'output field': 'm_nFieldOutput',
    'value to lerp to': 'm_vecOutput',
}),
'Remap Speed to Scalar': ('C_OP_RemapSpeed', {
    'input minimum': 'm_flInputMin',
    'input maximum': 'm_flInputMax',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'output is scalar of initial random range': 'm_bScaleInitialRange',
    'output is scalar of current value': 'm_bScaleCurrent',
}),
'Remap CP Speed to CP': (PreOP('C_OP_RemapSpeedtoCP'), {
    'input control point': 'm_nInControlPointNumber',
    'input minimum': 'm_flInputMin',
    'input maximum': 'm_flInputMax',
    'output control point': 'm_nOutControlPointNumber',
    'Output field 0-2 X/Y/Z': 'm_nField',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
}),
'Remap Model Volume to CP': ('C_OP_RemapModelVolumetoCP', {
    'input control point': 'm_nInControlPointNumber',
    'input volume minimum in cubic units': 'm_flInputMin',
    'input volume maximum in cubic units': 'm_flInputMax',
    'output control point': 'm_nOutControlPointNumber',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
}),
'Remap Particle BBox Volume to CP': ('C_OP_RemapBoundingVolumetoCP', {
    'input volume minimum in cubic units': 'm_flInputMin',
    'input volume maximum in cubic units': 'm_flInputMax',
    'output control point': 'm_nOutControlPointNumber',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
}),
'Remap Average Scalar Value to CP': ('C_OP_RemapAverageScalarValuetoCP', {
    'Scalar field': 'm_nField',
    'input volume minimum': 'm_flInputMin',
    'input volume maximum': 'm_flInputMax',
    'output control point': 'm_nOutControlPointNumber',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
}),
'Ramp Scalar Linear Random': ('C_OP_RampScalarLinear', {
    'ramp field': 'm_nField',
    'ramp rate min': 'm_RateMin',
    'ramp rate max': 'm_RateMax',
    'start time min': 'm_flStartTime_min',
    'start time max': 'm_flStartTime_max',
    'end time min': 'm_flEndTime_min',
    'end time max': 'm_flEndTime_max',
    'start/end proportional': 'm_bProportionalOp',
}),
'Ramp Scalar Spline Random': ('C_OP_RampScalarSpline', {
    'ramp field': 'm_nField',
    'ramp rate min': 'm_RateMin',
    'ramp rate max': 'm_RateMax',
    'start time min': 'm_flStartTime_min',
    'start time max': 'm_flStartTime_max',
    'end time min': 'm_flEndTime_min',
    'end time max': 'm_flEndTime_max',
    'start/end proportional': 'm_bProportionalOp',
    'ease out': 'm_bEaseOut',
    'bias': 'm_flBias',
}),
'Ramp Scalar Linear Simple': ('C_OP_RampScalarLinearSimple', {
    'ramp field': 'm_nField',
    'ramp rate': 'm_Rate',
    'start time': 'm_flStartTime',
    'end time': 'm_flEndTime',
}),
'Ramp Scalar Spline Simple': ('C_OP_RampScalarSplineSimple', {
    'ramp field': 'm_nField',
    'ramp rate': 'm_Rate',
    'start time': 'm_flStartTime',
    'end time': 'm_flEndTime',
    'ease out': 'm_bEaseOut',
}),
'Noise Scalar': ('C_OP_Noise', {
    'noise coordinate scale': 'm_fl4NoiseScale',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'additive': 'm_bAdditive',
}),
'Noise Vector': ('C_OP_VectorNoise', {
    'noise coordinate scale': 'm_fl4NoiseScale',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_vecOutputMin',
    'output maximum': 'm_vecOutputMax',
    'additive': 'm_bAdditive',
}),
'Lifespan Decay': ('C_OP_Decay', {
}),
'Lifespan Minimum Velocity Decay': ('C_OP_VelocityDecay', {
    'minimum velocity': 'm_flMinVelocity',
}),
'Lifespan Minimum Alpha Decay': ('C_OP_AlphaDecay', {
    'minimum alpha': 'm_flMinAlpha',
}),
'Lifespan Minimum Radius Decay': ('C_OP_RadiusDecay', {
    'minimum radius': 'm_flMinRadius',
}),
'Lifespan Maintain Count Decay': ('C_OP_DecayMaintainCount', {
    'count to maintain': 'm_nParticlesToMaintain',
    'decay delay': 'm_flDecayDelay',
    'maintain count scale control point': 'm_nScaleControlPoint',
    'maintain count scale control point field': 'm_nScaleControlPointField',
}),
'Cull Random': ('C_OP_Cull', {
    'Cull Start Time': 'm_flCullStart',
    'Cull End Time': 'm_flCullEnd',
    'Cull Time Exponent': 'm_flCullExp',
    'Cull Percentage': 'm_flCullPerc',
}),
'Rotation Spin Roll': ('C_OP_Spin', {
    'spin_rate_degrees': 'm_nSpinRateDegrees',
    'spin_stop_time': 'm_fSpinRateStopTime',
    'spin_rate_min': 'm_nSpinRateMinDegrees',
}),
'Rotation Basic': ('C_OP_SpinUpdate', {
}),
'Rotation Spin Yaw': ('C_OP_SpinYaw', {
    'yaw_rate_degrees': 'm_nSpinRateDegrees',
    'yaw_stop_time': 'm_fSpinRateStopTime',
    'yaw_rate_min': 'm_nSpinRateMinDegrees',
}),
'Radius Scale': ('C_OP_InterpolateRadius', {
    'start_time': 'm_flStartTime',
    'end_time': 'm_flEndTime',
    'radius_start_scale': 'm_flStartScale',
    'radius_end_scale': 'm_flEndScale',
    'ease_in_and_out': 'm_bEaseInAndOut',
    'scale_bias': 'm_flBias',
}),
'Color Fade': ('C_OP_ColorInterpolate', {
    'color_fade': 'm_ColorFade',
    'fade_start_time': 'm_flFadeStartTime',
    'fade_end_time': 'm_flFadeEndTime',
    'ease_in_and_out': 'm_bEaseInOut',
    'output field': 'm_nFieldOutput',
}),
'Movement Lock to Control Point': ('C_OP_PositionLock', {
    'control_point_number': 'm_nControlPointNumber',
    'start_fadeout_min': 'm_flStartTime_min',
    'start_fadeout_max': 'm_flStartTime_max',
    'start_fadeout_exponent': 'm_flStartTime_exp',
    'end_fadeout_min': 'm_flEndTime_min',
    'end_fadeout_max': 'm_flEndTime_max',
    'end_fadeout_exponent': 'm_flEndTime_exp',
    'distance fade range': 'm_flRange',
    'lock rotation': 'm_bLockRot',
}),
'Color Light from Control Point': ('C_OP_ControlpointLight', {
    'Light 1 Control Point': 'm_nControlPoint1',
    'Light 1 Control Point Offset': 'm_vecCPOffset1',
    'Light 1 Type 0=Point 1=Spot': 'm_bLightType1',
    'Light 1 Color': 'm_LightColor1',
    'Light 1 Dynamic Light': 'm_bLightDynamic1',
    'Light 1 Direction': ObjectP('m_LightNode1', 'm_Direction'),
    'Light 1 50% Distance': 'm_LightFiftyDist1',
    'Light 1 0% Distance': 'm_LightZeroDist1',
    'Light 1 Spot Inner Cone': ObjectP('m_LightNode1', 'm_Theta'),
    'Light 1 Spot Outer Cone': ObjectP('m_LightNode1', 'm_Phi'),
    'Light 2 Control Point': 'm_nControlPoint2',
    'Light 2 Control Point Offset': 'm_vecCPOffset2',
    'Light 2 Type 0=Point 1=Spot': 'm_bLightType2',
    'Light 2 Color': 'm_LightColor2',
    'Light 2 Dynamic Light': 'm_bLightDynamic2',
    'Light 2 Direction': ObjectP('m_LightNode2', 'm_Direction'),
    'Light 2 50% Distance': 'm_LightFiftyDist2',
    'Light 2 0% Distance': 'm_LightZeroDist2',
    'Light 2 Spot Inner Cone': ObjectP('m_LightNode2', 'm_Theta'),
    'Light 2 Spot Outer Cone': ObjectP('m_LightNode2', 'm_Phi'),
    'Light 3 Control Point': 'm_nControlPoint3',
    'Light 3 Control Point Offset': 'm_vecCPOffset3',
    'Light 3 Type 0=Point 1=Spot': 'm_bLightType3',
    'Light 3 Color': 'm_LightColor3',
    'Light 3 Dynamic Light': 'm_bLightDynamic3',
    'Light 3 Direction': ObjectP('m_LightNode3', 'm_Direction'),
    'Light 3 50% Distance': 'm_LightFiftyDist3',
    'Light 3 0% Distance': 'm_LightZeroDist3',
    'Light 3 Spot Inner Cone': ObjectP('m_LightNode3', 'm_Theta'),
    'Light 3 Spot Outer Cone': ObjectP('m_LightNode3', 'm_Phi'),
    'Light 4 Control Point': 'm_nControlPoint4',
    'Light 4 Control Point Offset': 'm_vecCPOffset4',
    'Light 4 Type 0=Point 1=Spot': 'm_bLightType4',
    'Light 4 Color': 'm_LightColor4',
    'Light 4 Dynamic Light': 'm_bLightDynamic4',
    'Light 4 Direction': ObjectP('m_LightNode4', 'm_Direction'),
    'Light 4 50% Distance': 'm_LightFiftyDist4',
    'Light 4 0% Distance': 'm_LightZeroDist4',
    'Light 4 Spot Inner Cone': ObjectP('m_LightNode4', 'm_Theta'),
    'Light 4 Spot Outer Cone': ObjectP('m_LightNode4', 'm_Phi'),
    'Initial Color Bias': 'm_flScale',
    'Clamp Minimum Light Value to Initial Color': 'm_bClampLowerRange',
    'Clamp Maximum Light Value to Initial Color': 'm_bClampUpperRange',
    'Compute Normals From Control Points': 'm_bUseNormal',
    'Half-Lambert Normals': 'm_bUseHLambert',
}),
'Set child control points from particle positions': ('C_OP_SetChildControlPoints', {
    'Group ID to affect': 'm_nChildGroupID',
    'First control point to set': 'm_nFirstControlPoint',
    '# of control points to set': 'm_nNumControlPoints',
    'first particle to copy': 'm_nFirstSourcePoint',
    'set orientation': 'm_bSetOrientation',
}),
'Set control points from particle positions': ('C_OP_SetControlPointsToParticle', {
    'First control point to set': 'm_nFirstControlPoint',
    '# of control points to set': 'm_nNumControlPoints',
    'first particle to copy': 'm_nFirstSourcePoint',
    'set orientation': 'm_bSetOrientation',
}),
'Set per child control point from particle positions': ('C_OP_SetPerChildControlPoint', {
    'Group ID to affect': 'm_nChildGroupID',
    'control point to set': 'm_nFirstControlPoint',
    '# of children to set': 'm_nNumControlPoints',
    'first particle to copy': 'm_nFirstSourcePoint',
    'set orientation': 'm_bSetOrientation',
}),
'Set Control Point Positions': (PreOP('C_OP_SetControlPointPositions'), {
    'First Control Point Number': 'm_nCP1',
    'First Control Point Parent': 'm_nCP1Parent',
    'First Control Point Location': 'm_vecCP1Pos',
    'Second Control Point Number': 'm_nCP2',
    'Second Control Point Parent': 'm_nCP2Parent',
    'Second Control Point Location': 'm_vecCP2Pos',
    'Third Control Point Number': 'm_nCP3',
    'Third Control Point Parent': 'm_nCP3Parent',
    'Third Control Point Location': 'm_vecCP3Pos',
    'Fourth Control Point Number': 'm_nCP4',
    'Fourth Control Point Parent': 'm_nCP4Parent',
    'Fourth Control Point Location': 'm_vecCP4Pos',
    'Set positions in world space': 'm_bUseWorldLocation',
    'Control Point to offset positions from': 'm_nHeadLocation',
}),
'Movement Dampen Relative to Control Point': ('C_OP_DampenToCP', {
    'control_point_number': 'm_nControlPointNumber',
    'falloff range': 'm_flRange',
    'dampen scale': 'm_flScale',
}),
'Remap Distance Between Two Control Points to Scalar': ('C_OP_DistanceBetweenCPs', {
    'distance minimum': 'm_flInputMin',
    'distance maximum': 'm_flInputMax',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'starting control point': 'm_nStartCP',
    'ending control point': 'm_nEndCP',
    'ensure line of sight': 'm_bLOS',
    'LOS collision group': 'm_CollisionGroupName',
    'Maximum Trace Length': 'm_flMaxTraceLength',
    'LOS Failure Scalar': 'm_flLOSScale',
    'output is scalar of initial random range': 'm_bScaleInitialRange',
    'output is scalar of current value': 'm_bScaleCurrent',
}),
'Remap Distance Between Two Control Points to CP': ('C_OP_DistanceBetweenCPsToCP', {
    'distance minimum': 'm_flInputMin',
    'distance maximum': 'm_flInputMax',
    'output control point': 'm_nOutputCP',
    'output control point field': 'm_nOutputCPField',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'starting control point': 'm_nStartCP',
    'ending control point': 'm_nEndCP',
    'ensure line of sight': 'm_bLOS',
    'LOS collision group': 'm_CollisionGroupName',
    'Maximum Trace Length': 'm_flMaxTraceLength',
    'LOS Failure Scale': 'm_flLOSScale',
}),
'Remap Percentage Between Two Control Points to Scalar': ('C_OP_PercentageBetweenCPs', {
    'percentage minimum': 'm_flInputMin',
    'percentage maximum': 'm_flInputMax',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'starting control point': 'm_nStartCP',
    'ending control point': 'm_nEndCP',
    'output is scalar of initial random range': 'm_bScaleInitialRange',
    'output is scalar of current value': 'm_bScaleCurrent',
    'only active within input range': 'm_bActiveRange',
    'treat distance between points as radius': 'm_bRadialCheck',
}),
'Remap Percentage Between Two Control Points to Vector': ('C_OP_PercentageBetweenCPsVector', {
    'percentage minimum': 'm_flInputMin',
    'percentage maximum': 'm_flInputMax',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_vecOutputMin',
    'output maximum': 'm_vecOutputMax',
    'starting control point': 'm_nStartCP',
    'ending control point': 'm_nEndCP',
    'output is scalar of initial random range': 'm_bScaleInitialRange',
    'output is scalar of current value': 'm_bScaleCurrent',
    'only active within input range': 'm_bActiveRange',
    'treat distance between points as radius': 'm_bRadialCheck',
}),
'Remap Distance to Control Point to Scalar': ('C_OP_DistanceToCP', {
    'distance minimum': 'm_flInputMin',
    'distance maximum': 'm_flInputMax',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'control point': 'm_nStartCP',
    'ensure line of sight': 'm_bLOS',
    'LOS collision group': 'm_CollisionGroupName',
    'Maximum Trace Length': 'm_flMaxTraceLength',
    'LOS Failure Scalar': 'm_flLOSScale',
    'output is scalar of initial random range': 'm_bScaleInitialRange',
    'output is scalar of current value': 'm_bScaleCurrent',
    'only active within specified distance': 'm_bActiveRange',
}),
'Set Control Point To Player': (PreOP('C_OP_SetControlPointToPlayer'), {
    'Control Point Number': 'm_nCP1',
    'Control Point Offset': 'm_vecCP1Pos',
    'Use Eye Orientation': 'm_bOrientToEyes',
}),
'Movement Lerp to Hitbox': ('C_OP_MoveToHitbox', {
    'control point number': 'm_nControlPointNumber',
    'lifetime lerp start': 'm_flLifeTimeLerpStart',
    'lifetime lerp end': 'm_flLifeTimeLerpEnd',
    'hitbox set': 'm_HitboxSetName',
}),
'Movement Lock to Bone': ('C_OP_LockToBone', {
    'control_point_number': 'm_nControlPointNumber',
    'lifetime fade start': 'm_flLifeTimeFadeStart',
    'lifetime fade end': 'm_flLifeTimeFadeEnd',
    'hitbox set': 'm_HitboxSetName',
}),
'Set CP Offset to CP Percentage Between Two Control Points': ('C_OP_CPOffsetToPercentageBetweenCPs', {
    'percentage minimum': 'm_flInputMin',
    'percentage maximum': 'm_flInputMax',
    'percentage bias': 'm_flInputBias',
    'starting control point': 'm_nStartCP',
    'ending control point': 'm_nEndCP',
    'offset control point': 'm_nOffsetCP',
    'input control point': 'm_nInputCP',
    'output control point': 'm_nOuputCP',
    'offset amount': 'm_vecOffset',
    'treat distance between points as radius': 'm_bRadialCheck',
    'treat offset as scale of total distance': 'm_bScaleOffset',
}),
'Cull when crossing plane': ('C_OP_PlaneCull', {
    'Control Point for point on plane': 'm_nPlaneControlPoint',
    'Cull plane offset': 'm_flPlaneOffset',
    'Plane Normal': 'm_vecPlaneDirection',
}),
'Cull when crossing sphere': ('C_OP_DistanceCull', {
    'Control Point': 'm_nControlPoint',
    'Cull Distance': 'm_flDistance',
    'Control Point offset': 'm_vecPointOffset',
    'Cull inside instead of outside': 'm_bCullInside',
}),
'Cull relative to model': ('C_OP_ModelCull', {
    'control_point_number': 'm_nControlPointNumber',
    'use only bounding box': 'm_bBoundBox',
    'cull outside instead of inside': 'm_bCullOutside',
    'hitbox set': 'm_HitboxSetName',
}),
"Set Control Point To Particles' Center": (PreOP('C_OP_SetControlPointToCenter'), {
    'Control Point Number to Set': 'm_nCP1',
    'Center Offset': 'm_vecCP1Pos',
}),
'Movement Match Particle Velocities': ('C_OP_VelocityMatchingForce', {
    'Direction Matching Strength': 'm_flDirScale',
    'Speed Matching Strength': 'm_flSpdScale',
    'Control Point to Broadcast Speed and Direction To': 'm_nCPBroadcast',
}),
'Movement Maintain Offset': ('C_OP_MovementMaintainOffset', {
    'Local Space CP': 'm_nCP',
    'Desired Offset': 'm_vecOffset',
    'Scale by Radius': 'm_bRadiusScale',
}),
'Movement Place On Ground': ('C_OP_MovementPlaceOnGround', {
    'offset': 'm_flOffset',
    'kill on no collision': 'm_bKill',
    'include water': 'm_bIncludeWater',
    'max trace length': 'm_flMaxTraceLength',
    'trace offset': 'm_flTraceOffset',
    'collision group': 'm_CollisionGroupName',
    'reference CP 1': 'm_nRefCP1',
    'reference CP 2': 'm_nRefCP2',
    'CP movement tolerance': 'm_flTolerance',
    'interpolation rate': 'm_flLerpRate',
    'interploation distance tolerance cp': 'm_nLerpCP',
}),
'Inherit Attribute From Parent Particle': ('C_OP_InheritFromParentParticlesV2', { # V2
}),
'Rotation Orient to 2D Direction': ('C_OP_OrientTo2dDirection', {
    'Rotation Offset': 'm_flRotOffset',
    'Spin Strength': 'm_flSpinStrength',
    'rotation field': 'm_nFieldOutput',
}),
'Restart Effect after Duration': ('C_OP_RestartAfterDuration', {
    'Minimum Restart Time': 'm_flDurationMin',
    'Maximum Restart Time': 'm_flDurationMax',
    'Control Point to Scale Duration': 'm_nCP',
    'Control Point Field X/Y/Z': 'm_nCPField',
    'Only Restart Children': 'm_bOnlyChildren',
    'Child Group ID': 'm_nChildGroupID',
}),
'Stop Effect after Duration': ('C_OP_StopAfterCPDuration', {
    'Duration at which to Stop': 'm_flDuration',
    'Control Point to Scale Duration': 'm_nCP',
    'Control Point Field X/Y/Z': 'm_nCPField',
    'Destroy All Particles Immediately': 'm_bDestroyImmediately',
    'Play End Cap Effect': 'm_bPlayEndCap',
}),
'Rotation Orient Relative to CP': ('C_OP_Orient2DRelToCP', {
    'Rotation Offset': 'm_flRotOffset',
    'Spin Strength': 'm_flSpinStrength',
    'Control Point': 'm_nCP',
    'rotation field': 'm_nFieldOutput',
}),
'Set Control Point Rotation': (PreOP('C_OP_SetControlPointRotation'), {
    'Rotation Axis': 'm_vecRotAxis',
    'Rotation Rate': 'm_flRotRate',
    'Control Point': 'm_nCP',
    'Local Space Control Point': 'm_nLocalCP',
}),
'Movement Rotate Particle Around Axis': ('C_OP_MovementRotateParticleAroundAxis', {
    'Rotation Axis': 'm_vecRotAxis',
    'Rotation Rate': 'm_flRotRate',
    'Control Point': 'm_nCP',
    'Use Local Space': 'm_bLocalSpace',
}),
'Rotate Vector Random': ('C_OP_RotateVector', {
    'output field': 'm_nFieldOutput',
    'Rotation Axis Min': 'm_vecRotAxisMin',
    'Rotation Axis Max': 'm_vecRotAxisMax',
    'Rotation Rate Min': 'm_flRotRateMin',
    'Rotation Rate Max': 'm_flRotRateMax',
    'Normalize Ouput': 'm_bNormalize',
}),
'Movement Max Velocity': ('C_OP_MaxVelocity', {
    'Maximum Velocity': 'm_flMaxVelocity',
    'Override Max Velocity from this CP': 'm_nOverrideCP',
    'Override CP field': 'm_nOverrideCPField',
}),
'Movement Lag Compensation': ('C_OP_LagCompensation', {
    'Desired Velocity CP': 'm_nDesiredVelocityCP',
    'Desired Velocity CP Field Override(for speed only)': 'm_nDesiredVelocityCPField',
    'Latency CP': 'm_nLatencyCP',
    'Latency CP field': 'm_nLatencyCPField',
}),
'Movement Maintain Position Along Path': ('C_OP_MaintainSequentialPath', {
    'maximum distance': 'm_fMaxDistance',
    **(_m_PathParams:={'bulge': ObjectP('m_PathParams', 'm_flBulge'),
    'start control point number': ObjectP('m_PathParams', 'm_nStartControlPointNumber'),
    'end control point number': ObjectP('m_PathParams', 'm_nEndControlPointNumber'),
    'bulge control 0=random 1=orientation of start pnt 2=orientation of end point': ObjectP('m_PathParams', 'm_nBulgeControl'),
    'mid point position': ObjectP('m_PathParams', 'm_flMidPoint'),}),
    'particles to map from start to end': 'm_flNumToAssign',
    'restart behavior (0 = bounce, 1 = loop )': 'm_bLoop',
    'cohesion strength': 'm_flCohesionStrength',
    'use existing particle count': 'm_bUseParticleCount',
    'control point movement tolerance': 'm_flTolerance',
}),
'Movement Lock to Saved Position Along Path': ('C_OP_LockToSavedSequentialPathV2', { # V2
    'Use sequential CP pairs between start and end point': 'm_bCPPairs',
    **_m_PathParams,
}),
'Remap Dot Product to Scalar': ('C_OP_RemapDotProductToScalar', {
    'use particle velocity for first input': 'm_bUseParticleVelocity',
    'first input control point': 'm_nInputCP1',
    'second input control point': 'm_nInputCP2',
    'input minimum (-1 to 1)': 'm_flInputMin',
    'input maximum (-1 to 1)': 'm_flInputMax',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'output is scalar of initial random range': BoolToSetKV('m_nSetMethod', "PARTICLE_SET_SCALE_CURRENT_VALUE"),#'m_bScaleInitialRange',
    'output is scalar of current value': BoolToSetKV('m_nSetMethod', "PARTICLE_SET_SCALE_INITIAL_VALUE"),#'m_bScaleCurrent',
    'only active within specified input range': 'm_bActiveRange',
}),
'Remap Control Point to Scalar': ('C_OP_RemapCPtoScalar', {
    'emitter lifetime start time (seconds)': 'm_flStartTime',
    'emitter lifetime end time (seconds)': 'm_flEndTime',
    'input control point number': 'm_nCPInput',
    'input minimum': 'm_flInputMin',
    'input maximum': 'm_flInputMax',
    'input field 0-2 X/Y/Z': 'm_nField',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_flOutputMin',
    'output maximum': 'm_flOutputMax',
    'output is scalar of initial random range': 'm_bScaleInitialRange',
    'output is scalar of current value': 'm_bScaleCurrent',
}),
'Normal Lock to Control Point': ('C_OP_NormalLock', {
    'control_point_number': 'm_nControlPointNumber',
}),
'Set Control Point to Impact Point': (PreOP('C_OP_SetControlPointToImpactPoint'), {
    'Control Point to Set': 'm_nCPOut',
    'Control Point to Trace From': 'm_nCPIn',
    'Trace Direction Override': 'm_vecTraceDir',
    'Trace Update Rate': 'm_flUpdateRate',
    'Max Trace Length': 'm_flTraceLength',
    'Offset End Point Amount': 'm_flOffset',
    'trace collision group': 'm_CollisionGroupName',
}),
'Remap Control Point to Vector': ('C_OP_RemapCPtoVector', {
    'emitter lifetime start time (seconds)': 'm_flStartTime',
    'emitter lifetime end time (seconds)': 'm_flEndTime',
    'input control point number': 'm_nCPInput',
    'input minimum': 'm_vInputMin',
    'input maximum': 'm_vInputMax',
    'output field': 'm_nFieldOutput',
    'output minimum': 'm_vOutputMin',
    'output maximum': 'm_vOutputMax',
    'output is scalar of initial random range': 'm_bScaleInitialRange',
    'output is scalar of current value': 'm_bScaleCurrent',
    'offset position': 'm_bOffset',
    'accelerate position': 'm_bAccelerate',
    'local space CP': 'm_nLocalSpaceCP',
}),
'Remap Velocity to Vector': ('C_OP_RemapVelocityToVector', {
    'output field': 'm_nFieldOutput',
    'normalize': 'm_bNormalize',
    'scale factor': 'm_flScale',
}),
'Remap CP Velocity to Vector': ('C_OP_RemapCPVelocityToVector', {
    'output field': 'm_nFieldOutput',
    'control point': 'm_nControlPoint',
    'normalize': 'm_bNormalize',
    'scale factor': 'm_flScale',
}),
'Set CP Orientation to CP Direction': ('C_OP_SetCPOrientationToDirection', {
    'input control point': 'm_nInputControlPoint',
    'output control point': 'm_nOutputControlPoint',
}),
'Remap Direction to CP to Vector': ('C_OP_RemapDirectionToCPToVector', {
    'control point': 'm_nCP',
    'output field': 'm_nFieldOutput',
    'normalize': 'm_bNormalize',
    'offset axis': 'm_vecOffsetAxis',
    'offset rotation': 'm_flOffsetRot',
    'scale factor': 'm_flScale',
}),
'Normalize Vector': ('C_OP_NormalizeVector', {
    'output field': 'm_nFieldOutput',
    'scale factor': 'm_flScale',
}),
'Remap Control Point Direction to Vector': ('C_OP_RemapControlPointDirectionToVector', {
    'output field': 'm_nFieldOutput',
    'control point number': 'm_nControlPointNumber',
    'scale factor': 'm_flScale',
}),
}
def verify_ops():
    addthese = ''
    for k, v in t2.items():
        if isinstance(v, tuple):
            op, subs = v
        else:
            op = v
            subs = t2
        old_v = t[k]
        oldsubs = t
        if isinstance(old_v, tuple):
            old_v, oldsubs = old_v
        print(f' ~~~ {op}')
        if k not in t:
            addthese += f"{' '*8}'{k}': '{op}',\n"
        else:
            if old_v != op:
                print(f"Mismatch with `{k}`:  '{old_v}' != '{op}'")
        ### verify subs
        for subk, subv in subs.items():
            if subk in oldsubs:
                if not oldsubs[subk]:
                     addthese += f"{' '*12}'{subk}': '{subv}',\n"
                elif str(oldsubs[subk]) != str(subv):
                    print(f"Key mismatch with `{subk}`:  '{oldsubs[subk]}' != '{subv}'")

    if addthese:
        print()
        print(addthese)
        print()
verify_ops()
quit()
test = """
'Lifespan Decay': 'C_OP_Decay',
'lifespan_decay': 'C_OP_Decay',
    # m_bRopeDecay
'Radius Scale': 'C_OP_InterpolateRadius',
    'radius_start_scale': 'm_flStartScale',
    'radius_end_scale': 'm_flEndScale',
    'start_time': 'm_flStartTime',
    'scale_bias': 'm_flBias',
    'end_time': 'm_flEndTime',
    'ease_in_and_out': 'm_bEaseInAndOut',

'Alpha Fade In Random': 'C_OP_FadeIn',
'alpha_fade_in_random': 'C_OP_FadeIn',
    'proportional 0/1': 'm_bProportional',
"""

test2 = ''
for line in t.splitlines():
    if line[:4] != '    ':
        lp = line.split(':')
        if len(lp) == 2:
            s = lp[1].lstrip()
            comment = ''
            if s.startswith('('):
                test2 += line + '\n'
                continue
            if '#' in s:
                s, comment = tuple(s.split('#', 1))
                test2+= f"{'}'}),\n{lp[0]}: ({s} {'{' } #{comment}\n"
            else:
                test2+= f"{'}'}),\n{lp[0]}: ({s} {'{'}\n"
        else:
            test2 += line + '\n'
    else:
        test2 += line + '\n'
print(test2)